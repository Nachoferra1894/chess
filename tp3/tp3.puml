@startuml
'Pieces
interface Piece {
    - name: String
    + isActive(): boolean
    + getPosition(): Square
    + getColor(): string
    + getName(): string
}
class CommonPiece implements Piece {
    + move(sq: Square)
}
class PromotablePiece implements Piece {
    + move(sq: Square)
    + promoteTo(pc: Piece)
}
'Game objects
class Game {
    - board: Board
    - ruleController: RuleController
    - startTime: Timestamp
    - activeTurn: Player
    - players: Player[]
    - pieces: Piece[]
    + startGame()
    + move(py: Player,pc: Piece,sq: Square)
    + endGame(winner?: Player)
}
class BoardGenerator {
    + createBoard(columns,rows,pieces)
}
class PieceGenerator {
    + createPiece(name,color)
}
class PlayerGenerator{
    + createPlayer(name)
}
Player <-- PlayerGenerator
Board <-- BoardGenerator
Piece <-- PieceGenerator


interface Square {
    + isOccupied()

}
class PositionSquare implements Square{
    - row: Number
    - column: Number
    - piece?: Piece
    + getRow()
    + getColumn()
    + getPiece(): Piece
}
class OccupiedSquare extends PositionSquare{
    - occupiedBy: Piece
    + getPiece: Piece
    + isOccupied(): True
}
class EmptySquare extends PositionSquare{
    + isOccupied(): False
}
interface Board {
    + getSquareOccupation(sq: Square): Piece
}
class SquareBoard implements Board{
    - squares: Square[]
}
'class Timer {
'    - startGameTime: Timestamp
'    - maxTime: Timestamp
'    + resumeTimer()
'    + stopTimer()
'    + endGame()
'}

interface Player {
    - pieceColor: string
    + getCanMove(): Boolean
    + getTimeLeft(): Timestamp
    + makeMove(sqFrom: Square,sqTo: Square)
    + offerStalemate()
    + respondStalemate(): boolean
    + resign()
}
class HumanPlayer {
    - name: string
}
HumanPlayer ..|> Player
Game --*  Piece


Game *--  Board
Player --*  Game

'Rules
class RuleController {
    - endGameRules: EndGameRules[]
    - rulesByPiece: {piece: Piece,rules: Rule[]}[]
    + getPieceRules(piece: Piece): Rule[]
}

RuleController *-- Rule
RuleController *--  EndGameRule
Game *-- RuleController

interface EndGameRule {
    + hasGameFinished()
}
class StaleMateRule implements EndGameRule{
    + hasGameFinished()
}
class FiftyKingMoves implements EndGameRule{
    + hasGameFinished()
}
class CheckMateRule implements EndGameRule{
    + hasGameFinished()
}
interface Rule {
    + isPossible(pieces Piece[],board Board,possibleMovement: Movement): Boolean
}
class IsOnCheckRule implements Rule{
}
class MaxBoardRule implements Rule {
}
class NoPieceCrash implements Rule {
}
class CastleRule implements Rule {
}
class PassantCaptureRule implements Rule {
}
class PromoteRule implements Rule {
}
interface MoveRule extends Rule {
    - limit: <Optional> int
}
class HorizontalMoveRule implements MoveRule {
}
class VerticalMoveRule implements MoveRule {
}
class DiagonalMoveRule implements MoveRule {
}


@enduml